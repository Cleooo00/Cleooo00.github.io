<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[围棋算法]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%9B%B4%E6%A3%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面 经过一周的实训课，终于也做出了一个小东西，关于围棋的算法，为了偷懒直接ctrl v了题目（滑稽保命ε＝ε＝ε＝(#&gt;д&lt;)ﾉ） 题目 围棋是世界范围内非常流行的棋类运动，是竞技体育项目。围棋的规则非常简单，做为编程初学者逻辑思维训练非常合适。 标准围棋棋盘是19行19列。为了简化起见，此处简化成9行9列。 标准围棋对弈方法是黑方和白方轮番下棋，为了简化，本算法引擎，支持任意的落子顺序，即落子顺序由程序输入 输入(棋子角色，棋子行号，棋子列号)​ 1 2 3 表示白子放第2行第3列 2 3 3 表示黑子放第3行第3列 本算法引擎实现的是。从落子序列到棋盘状态的映射，当落子完成后，输出最终的棋盘状态。 +代表空白，o代表白棋，#代表黑棋 例如 1 1 1 1 1 2 1 2 1 1 2 2 输出 四颗白子形成的正方形状 围棋对战算法引擎需要实现各种围棋规则(提子，禁入点，反扑，劫)。具体的规则示意图请自行网上查阅。 样例 输入： 1 1 1 2 2 2 输出： ​ 1 2 3 4 5 6 7 8 9 1 o + + + + + + + + 2 + # + + + + + + + 3 + + + + + + + + + 4 + + + + + + + + + 5 + + + + + + + + + 6 + + + + + + + + + 7 + + + + + + + + + 8 + + + + + + + + + 9 + + + + + + + + + 逻辑思路 输入数据后，判断该位置是否为空，空位可落子 每次输入数据时调用jieInit（）函数初始化，（用一个数组单独记录棋盘上一轮被提走的棋子的位置） 调用judgeLive（）函数判断自己落子的位置是否会处于自杀状态​ （1）如果是，则调用chessAnotherJudge（）函数判断周围是否有敌方棋子即将被杀（反扑）​ a.如果是，则执行反扑chessAnotherClear（）（寻找并清除周围敌方濒死棋子）​ b.如果否，则该点为禁入点，不可落子​ （2）如果否，则直接判断周围是否有敌方棋子即将被杀，并视情况执行清除敌方命令 打劫，每次有棋子被提走后，jie[][]会记录提走的位置，并将记录保存到下一次输入后，在下一次输入判断时，会直接判断是否为劫 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&gt; #include&lt;iostream&gt;&gt; using namespace std;&gt; /*---------------------全局变量------------------*/&gt; &gt; int chessData[9][9]; //定义每个位置状态，0为空，1为白，2为黑&gt; const char chessChar[3]&#123; '+','o','#' &#125;;&gt; bool jie[9][9];&gt; &gt; /*---------------------函数-------------------*/&gt; &gt; /*打印棋盘*/&gt; void showChessBoard(void)&gt; &#123;&gt; cout &lt;&lt; " ";&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1;&gt; &#125;&gt; cout &lt;&lt; endl;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1 &lt;&lt; " ";&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; int data = chessData[i][j];&gt; cout &lt;&lt; chessChar[data] &lt;&lt; " ";&gt; &#125;&gt; cout &lt;&lt; endl;&gt; &#125;&gt; &#125;&gt; &gt; /*寻找相反状态*/&gt; int anotherRole(int qi)&gt; &#123;&gt; if (qi == 1)&gt; return 2;&gt; if (qi == 2)&gt; return 1;&gt; &#125;&gt; &gt; /*具体执行递归判定*/&gt; bool judgeNeigbourLive(int role, int x, int y, bool footprint[])&gt; &#123;&gt; if (x &lt; 0 || x &gt;= 9 || y &lt; 0 || y &gt;= 9)//如果我超界，返回false&gt; &#123;&gt; return false;&gt; &#125;&gt; if (footprint[x * 9 + y] == true) //如果我来过这个地方，返回false，不在判断&gt; &#123;&gt; return false;&gt; &#125;&gt; if (chessData[x][y] == 0) //如果我为空，则邻居必定存活，即有气&gt; &#123;&gt; return true;&gt; &#125;&gt; if (chessData[x][y] == anotherRole(role))//如果我跟邻居的状态不同，则不判断&gt; &#123;&gt; return false;&gt; &#125;&gt; &gt; footprint[x * 9 + y] = true;//每次判断完一个位置后就把该位置设为true，表示来过&gt; &gt; //如果我跟邻居的状态相同，则递归判断邻居&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125;&gt; &gt; /*递归判定是否存活*/&gt; bool judgeLive(int role, int x, int y)&gt; &#123;&gt; bool footprint[9 * 9] = &#123; false &#125;; //用足迹记录下每一次走过的位置，避免重复判定引起无穷递归&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125; &gt; &gt; /*清除传入点周围的敌方棋子*/&gt; void chessClear(int qi, int x, int y) //递归寻找所有相同状态的点并将其提起&gt; &#123;&gt; if (chessData[x - 1][y] == qi)&gt; &#123;&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; chessClear(qi, x - 1, y);&gt; &#125;&gt; if (chessData[x + 1][y] == qi)&gt; &#123;&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; chessClear(qi, x + 1, y);&gt; &#125;&gt; if (chessData[x][y - 1] == qi)&gt; &#123;&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; chessClear(qi, x, y - 1);&gt; &#125;&gt; if (chessData[x][y + 1] == qi)&gt; &#123;&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; chessClear(qi, x, y + 1);&gt; &#125;&gt; &#125;&gt; &gt; /*寻找传入点周围的濒死敌方棋子并提供信息给chessClear函数*/&gt; void chessAnotherClear(int x, int y) //判断落子后邻居是否存活，若死亡，则连片提子&gt; &#123;&gt; if (judgeLive(chessData[x - 1][y], x - 1, y) == false) //如果点左边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x - 1][y], x - 1, y);&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x + 1][y], x + 1, y) == false) //如果点右边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x + 1][y], x + 1, y);&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y + 1], x, y + 1) == false) //如果点上边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y + 1], x, y + 1);&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y - 1], x, y - 1) == false) //如果点下边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y - 1], x, y - 1);&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; &#125;&gt; &#125;&gt; &gt; /*判定传入点周围是否存在濒死敌方棋子*/&gt; bool chessAnotherJudge(int qi,int x, int y) &gt; &#123;&gt; if ((judgeLive(chessData[x - 1][y], x - 1, y) == false &amp;&amp; chessData[x - 1][y]==anotherRole(qi)) //如果四周存在必死的棋子，且必死的棋子为敌方棋子，则返回1，表示这个位置可以落子&gt; || judgeLive(chessData[x + 1][y], x + 1, y) == false &amp;&amp; chessData[x + 1][y] == anotherRole(qi)&gt; || judgeLive(chessData[x][y + 1], x, y + 1) == false &amp;&amp; chessData[x][y + 1] == anotherRole(qi)&gt; || judgeLive(chessData[x][y - 1], x, y - 1) == false &amp;&amp; chessData[x][y - 1] == anotherRole(qi))&gt; &#123;&gt; &gt; return 1;&gt; &#125;&gt; else&gt; return 0;&gt; &gt; &#125;&gt; &gt; /*初始化jie数组*/&gt; void jieInit()&gt; &#123;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; jie[i][j] = false;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; &gt; /*----------------------主函数------------------------*/&gt; int main()&gt; &#123;&gt; jieInit();&gt; int qi, x, y;&gt; for (; cin &gt;&gt; qi &gt;&gt; x &gt;&gt; y;)&gt; &#123;&gt; if (chessData[x - 1][y - 1] == 0 &amp;&amp; jie[x - 1][y - 1] == false)&gt; &#123;&gt; jieInit();&gt; chessData[x - 1][y - 1] = qi;&gt; if (judgeLive(qi, x - 1, y - 1) == true) //如果自己可以存活&gt; &#123;&gt; chessAnotherClear(x - 1, y - 1); //寻找并清除敌方无气子&gt; &#125;&gt; if (judgeLive(qi, x - 1, y - 1) == false) //如果自己不可存活&gt; &#123;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 0) //如果周围可以存活，则禁入&gt; &#123;&gt; chessData[x - 1][y - 1] = 0;&gt; &#125;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 1) //如果周围不可存活，则提子&gt; &#123;&gt; chessAnotherClear( x - 1, y - 1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; showChessBoard();&gt; &#125;&gt; &gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端部分基础知识]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[doctype html的作用 它是html5标准网页声明,告诉浏览器用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。而混杂模式指的是浏览器用自己的方式解析代码，页面会以一种兼容的方式来显示。混杂模式一般会模拟老站点的行为以防止老站点无法工作。 常见的meta标签的含义 指定所用的字符集 &lt;meta charset=&quot;utf-8&quot;&gt; 向搜索引擎说明网页的搜索关键词 &lt;meta name=&quot;keywords&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的主要内容 &lt;meta name=&quot;description&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的作者 &lt;meta name=&quot;author&quot; content=&quot;CleFke*^▽^*&quot;&gt; 浏览器的内核控制 &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; 常见的浏览器的内核 普通的IE浏览器使用的是Trident Firefox使用的是Gecko opera使用的是Presto，以及后面的Blink Safari以及Chrome使用的是WebKit 常见的标签以及含义 标签 含义 &lt;html&gt; HTML页面根元素 &lt;head&gt; 文档的头部 &lt;meta&gt; 为机器提供元数据，告诉机器如何解析 &lt;title&gt; 文档的标题 &lt;body&gt; 文档的内容 &lt;div&gt; 块级元素，容器 &lt;h1&gt; 定义一级标题，类似还有&lt;h2&gt;等 &lt;p&gt; 定义一个段落 &lt;a&gt; 定义一个链接，格式为&lt;a href=&quot;网址&quot;&gt; &lt;span&gt; 内联元素，可用作文本的容器 &lt;u&gt; 下划线标签 &lt;em&gt; 强调标签 &lt;strong&gt; 加重标签 &lt;table&gt; 表格标签 &lt;tr&gt; 表格中的行 &lt;td&gt; 表格中的单元格 &lt;th&gt; 表格的表头 &lt;tbody&gt; 表格的主体 &lt;tfoot&gt; 表格的页脚 &lt;ol&gt; 有序列表标签 &lt;ul&gt; 无序列表标签 &lt;li&gt; 定义列表项目 &lt;img&gt; 插入图片，格式为&lt;img src=&quot;图片地址&quot;&gt; &lt;br&gt; 换行标签 &lt;input&gt; 输入控件标签 &lt;i&gt; 斜体字标签 &lt;hr&gt; 水平线标签 &lt;iframe&gt; 定义内联框架 &lt;cite&gt; 定义作品标题 &lt;button&gt; 按钮标签 &lt;b&gt; 粗体字标签 &lt;form&gt; 定义供用户输入的表单 &lt;caption&gt; 定义表标题 &lt;footer&gt; 定义文档页脚]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些莫名其妙的东西]]></title>
    <url>%2F2019%2F08%2F31%2F%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[写在前面在室友的怂恿下，莫名其妙的有了搭建blog的想法，就首先感谢下铺的大哥的支持。由于一些众所周知的原因（没钱）这个小站基于Hexo+GitHub搭建。平时主要用来发表一些小文章，一点小感悟。 关于自己软件专业学生，现大二。学无所成，学无所成，学无所成。在周围人都找到自己方向的情况下，总觉得该做点什么。不管怎么样，找到自己的路吧。。溜了溜了。]]></content>
  </entry>
</search>
