<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet url-pattern路径匹配问题]]></title>
    <url>%2F2020%2F05%2F16%2FServlet-url-pattern%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面 在Servlet映射过程中，遇到了一个路径匹配的问题，遂做记录。 如图所示 原思路在login.html页面中有一个form表单，现在想利用action属性提交信息。 于是在xml文件中配置了如下信息： 12345678&lt;servlet&gt; &lt;servlet-name&gt;LoginCheck&lt;/servlet-name&gt; &lt;servlet-class&gt;com.login.Users&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginCheck&lt;/servlet-name&gt; &lt;url-pattern&gt;/loginCheck&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在表单属性中： 1&lt;form action="loginCheck" method="post"&gt; 问题此时，是找不到loginCheck目标的。经过查阅网上资料，发现url-pattern属性的初识位置是/web页面，若直接写/loginCheck表示从web根目录下面找文件。 解决因为目标在login.html里，html文件夹下，所以需要修改url-pattern的值为： 1&lt;url-pattern&gt;/html/loginCheck&lt;/url-pattern&gt; 这样才表示去html文件夹下寻找目标，才能正确匹配上。]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP实现简单登录]]></title>
    <url>%2F2020%2F05%2F09%2FJSP%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写在前面 在接触了JSP后，跟着老师简单做了一个小demo，模拟的登录操作 过程描述 首先是一个登录页面，通过表单接收数据； 将得到的数据封装进request对象，封装的内容为表单填写内容； 通过表单的method属性，用post方法发送到action指定的jsp文件，即检查用户信息的文件； 在检查文件连接数据库，并取出request传来的数据，传入sql语句进行数据库的匹配； 进入判断逻辑。判断成功，则通过jsp的forward page方法跳转到登陆成功页面，并携带参数；或是判断失败，跳转至失败页面。 代码 login.jsp 12345678910111213141516171819202122232425262728293031323334&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Login&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div style="text-align: center"&gt;&gt; &lt;h1&gt;Login&lt;/h1&gt;&gt; &lt;hr&gt;&gt; &lt;form action="login_check.jsp" method="post"&gt;&gt; &lt;table border="1"&gt;&gt; &lt;tr&gt;&gt; &lt;td colspan="2"&gt;Users Login&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td&gt;Login ID: &lt;/td&gt;&gt; &lt;td&gt;&lt;input type="text" name="id"&gt;&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td&gt;Password: &lt;/td&gt;&gt; &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td colspan="2"&gt;&gt; &lt;input type="submit" value="Submit"&gt;&gt; &lt;input type="reset" value="Reset"&gt;&gt; &lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;/table&gt;&gt; &lt;/form&gt;&gt; &lt;/div&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; login_check.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&gt; &lt;%--&gt; Created by IntelliJ IDEA.&gt; User: li&gt; Date: 2020/5/9&gt; Time: 10:53&gt; To change this template use File | Settings | File Templates.&gt; --%&gt;&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;%@ page import="java.sql.*"%&gt;&gt; &lt;%@ page import="javax.xml.stream.events.StartDocument" %&gt;&gt; &lt;%@ page import="javax.print.attribute.standard.PresentationDirection" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Check&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &gt; &lt;%!&gt; public static final String DRIVER = "com.mysql.jdbc.Driver";&gt; public static final String URL = "jdbc:mysql://localhost:3306/logintest?characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8";&gt; public static final String USER = "####";&gt; public static final String PASSWORD = "####";&gt; %&gt;&gt; &lt;%&gt; Connection con = null; //数据库连接对象&gt; PreparedStatement pstmt = null; //数据库操作&gt; ResultSet res = null; //结果集&gt; boolean flag = false; //是否登录成功标志&gt; String name = null;&gt; %&gt;&gt; &lt;%&gt; try &#123;&gt; Class.forName(DRIVER); //加载驱动&gt; try &#123;&gt; con = DriverManager.getConnection(URL,USER,PASSWORD); //获取数据库连接&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; String sql = "SELECT name FROM admininfo WHERE id=? AND password=?";&gt; /*这个语句中的？表示占位符，相当于一个未知量，通过下面的setString方法，可以填充占位符的值*/&gt; &gt; pstmt = con.prepareStatement(sql); //实例化数据库操作对象&gt; &gt; /*这里的request是从login.jsp页面表单提交的数据，经过封装，传递过来，分别有两个参数 id和password*/&gt; /*通过request带有的方法可以分别获取到传递的数据*/&gt; try &#123;&gt; pstmt.setString(1,request.getParameter("id"));&gt; pstmt.setString(2,request.getParameter("password"));&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &gt; res = pstmt.executeQuery(); //此语句只能查询，若要执行insert delete update等操作 须使用execute方法&gt; &gt; if(res.next())&#123;&gt; name = res.getString(1); //参数1表示取第一列值&gt; flag = true;&gt; &#125;&gt; &#125; catch (ClassNotFoundException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &gt; //finally语句是在try的return语句执行之后，return返回之前执行&gt; finally &#123;&gt; try &#123;&gt; if(res != null)&#123;&gt; res.close();&gt; &#125;&gt; if(pstmt != null)&#123;&gt; pstmt.close();&gt; &#125;&gt; if(con != null)&#123;&gt; con.close();&gt; &#125;&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &#125;&gt; %&gt;&gt; &gt; &lt;%&gt; if(flag)&#123;&gt; %&gt;&gt; &lt;jsp:forward page="login_success.jsp"&gt;&gt; &lt;jsp:param name="username" value="&lt;%=name%&gt;"/&gt;&gt; &lt;/jsp:forward&gt;&gt; &lt;%&gt; &#125;else&#123;&gt; %&gt;&gt; &lt;jsp:forward page="login_failure.jsp"&gt;&lt;/jsp:forward&gt;&gt; &lt;%&gt; &#125;&gt; %&gt;&gt; &gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; login_success.jsp 1234567891011121314151617181920212223&gt; &lt;%--&gt; Created by IntelliJ IDEA.&gt; User: li&gt; Date: 2020/5/9&gt; Time: 10:53&gt; To change this template use File | Settings | File Templates.&gt; --%&gt;&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Login success&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;Login success!&lt;/h1&gt;&gt; &lt;h2&gt;Welcome!&gt; &lt;span style="color: red"&gt;&gt; &lt;%=request.getParameter("username")%&gt;&gt; &lt;/span&gt;&gt; &lt;/h2&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; login_failure.jsp 123456789101112131415&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;meta charset="UTF-8"&gt;&gt; &lt;title&gt;Failure&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;Login failure&lt;/h1&gt;&gt; &lt;h2&gt;&gt; Please try again!&gt; &lt;a href="login.jsp" style="color: red"&gt;Click here!&lt;/a&gt;&gt; &lt;/h2&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; 遇到的问题 在数据库连接关闭的时候需要加入判断逻辑，判断为非空才能正常关闭； 需要项目导入mysql-connector-java-8.0.20.jar包，首先要配置到项目下，然后再添加到Tomcat的lib库中。并且要注意版本的匹配问题，否则会导致连接失败。 项目中我的各个版本为 12345&gt; Mysql: 8.0.18&gt; Tomcat: 9.0.34&gt; connetion-jar包: 8.0.20&gt; jdk: 11.0.6&gt; 附上最后成功的截图 为什么要用Tomcat？一般的，可以用html语言直接编写前端界面，并且通过js渲染，css美化。但这个过程是一个静态的，只是相当于把数据发送给浏览器进行解析，相当于面对客户端的。 而Tomcat是生成一个动态的页面，在html中嵌入jsp语言，生成的页面是通过服务器端发送出来。而Tomcat相当于一个中间的工具，帮助我们实现了这个过程，把我们自己的电脑变成了服务器端。 关于具体机制，下次学到再说 ☆(￣▽￣)/$:*]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>JSP HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发基础]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 微信小程序开发跟前端网页开发流程类似，它是基于微信的架构下，所以须使用专门的环境。即便如此，还是有很多的问题。 前置准备 首先需要到官网注册一个小程序账号，之后一路填写相关信息。注意！在选择小程序类别的时候，第一类别如果选的游戏，那么只能进行小游戏开发；选择其他类别，才可以进行普通小程序开发。 注册完成后，可看到如下页面 在-开发-开发设置目录下，可以看到自己已经创建好的小程序ID，小程序秘钥 接下来根据系统类型在官网下载开发环境 配置好后进入，会要求填写之前生成的小程序ID，填写完毕后即可进入开发界面 文件结构 在环境内，可以看到类似如下的文件结构 其中 /images 目录为自定义的文件夹，用于存放图片 /pages 目录用于存放页面文件 /utils 目录用于存放工具文件 /app.js 存放页面初识的状态，一般为登录状态 /app.json 存放所有的页面路径 /app.wxss 存放总页面样式文件，类比css文件 开发准备 在开发环境内可以看到一个默认生成的页面，功能是点击获取头像。在第一次开发时，可以将 /util文件全部删除，将/pages目录下的logs文件全部删除，将index.wxml，index.wxss，index.js中全部代码删除 在index.js中输入page 通过tab补全page页面函数 此时的一个页面文件结构如下所示 此时一个index文件夹表示一个页面的全部逻辑，同理，可以创建多个文件，生成多个文件夹 wxml文件以及wxss文件分别对应html和css文件 每创建一个新的页面，需要在app.json中声明路径，否则会有报错 如图所示，第一个页面路径表示初始页面，也就是主页面；后面的路径表示其他自定义的页面 若想要实现各个页面之间的跳转逻辑，可在主页面的js文件中自定义跳转函数（官方类库 wx.navigateto），当遇到跳转事件时就可以以完成跳转 如图所示，此函数表示遇到事件执行时跳转到url对应路径下 遇到的问题 第一次接触时，结合网上代码想要实现一个贪吃蛇小程序，结果在调试端正常执行，在手机端无法正常运行。原因是微信原则上不允许开发者在小程序上开发游戏，所以进行了限制，如贪吃蛇中用到的页面刷新逻辑在手机端被加以了限制。 微信小程序在打包上传时有大小限制，2M，所以如果文件中有图片或者其他大文件，需压缩处理，或者将图片放到网上图床。 第一次上传时可以直接选体验版上传，不审核。 最后 贴一个当时想用requestAnimationFrame方法结果发现被限制了，只能在小游戏开发中用，然后找到了一个别人做好的轮子 1234567891011121314&gt; var lastFrameTime = 0;&gt; // 模拟 requestAnimationFrame&gt; var doAnimationFrame = function (callback) &#123;&gt; var currTime = new Date().getTime();&gt; var timeToCall = Math.max(0, 16 - (currTime - lastFrameTime));&gt; var id = setTimeout(function () &#123; callback(currTime + timeToCall); &#125;, timeToCall);&gt; lastFrameTime = currTime + timeToCall;&gt; return id;&gt; &#125;;&gt; // 模拟 cancelAnimationFrame&gt; var abortAnimationFrame = function (id) &#123;&gt; clearTimeout(id)&gt; &#125;&gt; 以及，我的图标在哪找的这里！]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编中变址寻址操作易错点]]></title>
    <url>%2F2020%2F05%2F07%2F%E6%B1%87%E7%BC%96%E4%B8%AD%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%93%8D%E4%BD%9C%E6%98%93%E9%94%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面 在汇编语言中，针对数组操作，可以使用间接寻址，或者变址寻址。在变址寻址操作时，遇到了一系列问题，遂做总结，避免再犯。 问题描述 有一个带有8个WORD型数据的数组，想要对其偶数项进行求和 间接寻址方法12345678910111213141516171819202122232425262728; Operators (Operator.asm); Demonstrates the TYPE, LENGTHOF, and SIZEOF operators.386.model flat,stdcall.stack 4096ExitProcess PROTO,stdcall:dword.dataarrofw WORD 1,2,1,2,1,2,1,2 ;数据中，偶数序求和结果为2*4，奇数序求和为1*4sum WORD 0.codemain PROC mov EDI,OFFSET arrofw add EDI,2 ;现在指向第二个数据 mov ECX,LENGTHOF arrofw mov AX,0L1: add AX,[EDI] ;依次累加 add EDI,2*TYPE arrofw ;求偶数序，所以向后偏移 LOOP L1 mov sum,AX invoke ExitProcess,0main ENDPEND main 带比例因子的变址寻址方法123456789101112131415161718192021222324252627; Operators (Operator.asm); Demonstrates the TYPE, LENGTHOF, and SIZEOF operators.386.model flat,stdcall.stack 4096ExitProcess PROTO,stdcall:dword.dataarrofw WORD 1,2,1,2,1,2,1,2 ;数据中，偶数序求和结果为2*4，奇数序求和为1*4sum WORD 0.codemain PROC mov AX,0 mov ESI,1 mov ECX,LENGTHOF arrofwL1: add AX,arrofw[ESI*TYPE arrofw] ;依次累加 add ESI,2 ;求偶数序，所以每次加2 LOOP L1 mov sum,AX invoke ExitProcess,0main ENDPEND main 犯的错误 在使用寄存器时，没有考虑数据类型为WORD型，应该使用16位寄存器AX，而不是32位的EAX等等寄存器； 为什么又使用了EDI，ESI等寄存器？因为在OFFSET指令中，返回的地址一般为32位的，所以用32位的EDI寄存器来存；ESI同理。 这里不能用DI或者SI]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>间接寻址</tag>
        <tag>带比例因子的变址寻址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[围棋算法]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%9B%B4%E6%A3%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面 围棋是世界范围内非常流行的棋类运动，是竞技体育项目。围棋的规则非常简单，做为编程初学者逻辑思维训练非常合适。 标准围棋棋盘是19行19列。为了简化起见，此处简化成9行9列。标准围棋对弈方法是黑方和白方轮番下棋，为了简化，本算法引擎，支持任意的落子顺序，即落子顺序由程序输入输入(棋子角色，棋子行号，棋子列号)​ 1 2 3 表示白子放第2行第3列 2 3 3 表示黑子放第3行第3列 本算法引擎实现的是。从落子序列到棋盘状态的映射，当落子完成后，输出最终的棋盘状态。 +代表空白，o代表白棋，#代表黑棋 例如1 1 11 1 21 2 11 2 2输出四颗白子形成的正方形状围棋对战算法引擎需要实现各种围棋规则(提子，禁入点，反扑，劫)。具体的规则示意图请自行网上查阅。 样例 输入： 1 1 1 2 2 2 输出： ​ 1 2 3 4 5 6 7 8 9 1 o + + + + + + + + 2 + # + + + + + + + 3 + + + + + + + + + 4 + + + + + + + + + 5 + + + + + + + + + 6 + + + + + + + + + 7 + + + + + + + + + 8 + + + + + + + + + 9 + + + + + + + + + 逻辑思路 输入数据后，判断该位置是否为空，空位可落子 每次输入数据时调用jieInit（）函数初始化，（用一个数组单独记录棋盘上一轮被提走的棋子的位置） 调用judgeLive（）函数判断自己落子的位置是否会处于自杀状态 （1）如果是，则调用chessAnotherJudge（）函数判断周围是否有敌方棋子即将被杀（反扑） ​ a.如果是，则执行反扑chessAnotherClear（）（寻找并清除周围敌方濒死棋子） ​ b.如果否，则该点为禁入点，不可落子 ​（2）如果否，则直接判断周围是否有敌方棋子即将被杀，并视情况执行清除敌方命令 打劫，每次有棋子被提走后，jie[][]会记录提走的位置，并将记录保存到下一次输入后，在下一次输入判断时，会直接判断是否为劫 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&gt; #include&lt;iostream&gt;&gt; using namespace std;&gt; /*---------------------全局变量------------------*/&gt; &gt; int chessData[9][9]; //定义每个位置状态，0为空，1为白，2为黑&gt; const char chessChar[3]&#123; '+','o','#' &#125;;&gt; bool jie[9][9];&gt; &gt; /*---------------------函数-------------------*/&gt; &gt; /*打印棋盘*/&gt; void showChessBoard(void)&gt; &#123;&gt; cout &lt;&lt; " ";&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1;&gt; &#125;&gt; cout &lt;&lt; endl;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1 &lt;&lt; " ";&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; int data = chessData[i][j];&gt; cout &lt;&lt; chessChar[data] &lt;&lt; " ";&gt; &#125;&gt; cout &lt;&lt; endl;&gt; &#125;&gt; &#125;&gt; &gt; /*寻找相反状态*/&gt; int anotherRole(int qi)&gt; &#123;&gt; if (qi == 1)&gt; return 2;&gt; if (qi == 2)&gt; return 1;&gt; &#125;&gt; &gt; /*具体执行递归判定*/&gt; bool judgeNeigbourLive(int role, int x, int y, bool footprint[])&gt; &#123;&gt; if (x &lt; 0 || x &gt;= 9 || y &lt; 0 || y &gt;= 9)//如果我超界，返回false&gt; &#123;&gt; return false;&gt; &#125;&gt; if (footprint[x * 9 + y] == true) //如果我来过这个地方，返回false，不在判断&gt; &#123;&gt; return false;&gt; &#125;&gt; if (chessData[x][y] == 0) //如果我为空，则邻居必定存活，即有气&gt; &#123;&gt; return true;&gt; &#125;&gt; if (chessData[x][y] == anotherRole(role))//如果我跟邻居的状态不同，则不判断&gt; &#123;&gt; return false;&gt; &#125;&gt; &gt; footprint[x * 9 + y] = true;//每次判断完一个位置后就把该位置设为true，表示来过&gt; &gt; //如果我跟邻居的状态相同，则递归判断邻居&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125;&gt; &gt; /*递归判定是否存活*/&gt; bool judgeLive(int role, int x, int y)&gt; &#123;&gt; bool footprint[9 * 9] = &#123; false &#125;; //用足迹记录下每一次走过的位置，避免重复判定引起无穷递归&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125; &gt; &gt; /*清除传入点周围的敌方棋子*/&gt; void chessClear(int qi, int x, int y) //递归寻找所有相同状态的点并将其提起&gt; &#123;&gt; if (chessData[x - 1][y] == qi)&gt; &#123;&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; chessClear(qi, x - 1, y);&gt; &#125;&gt; if (chessData[x + 1][y] == qi)&gt; &#123;&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; chessClear(qi, x + 1, y);&gt; &#125;&gt; if (chessData[x][y - 1] == qi)&gt; &#123;&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; chessClear(qi, x, y - 1);&gt; &#125;&gt; if (chessData[x][y + 1] == qi)&gt; &#123;&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; chessClear(qi, x, y + 1);&gt; &#125;&gt; &#125;&gt; &gt; /*寻找传入点周围的濒死敌方棋子并提供信息给chessClear函数*/&gt; void chessAnotherClear(int x, int y) //判断落子后邻居是否存活，若死亡，则连片提子&gt; &#123;&gt; if (judgeLive(chessData[x - 1][y], x - 1, y) == false) //如果点左边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x - 1][y], x - 1, y);&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x + 1][y], x + 1, y) == false) //如果点右边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x + 1][y], x + 1, y);&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y + 1], x, y + 1) == false) //如果点上边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y + 1], x, y + 1);&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y - 1], x, y - 1) == false) //如果点下边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y - 1], x, y - 1);&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; &#125;&gt; &#125;&gt; &gt; /*判定传入点周围是否存在濒死敌方棋子*/&gt; bool chessAnotherJudge(int qi,int x, int y) &gt; &#123;&gt; if ((judgeLive(chessData[x - 1][y], x - 1, y) == false &amp;&amp; chessData[x - 1][y]==anotherRole(qi)) //如果四周存在必死的棋子，且必死的棋子为敌方棋子，则返回1，表示这个位置可以落子&gt; || judgeLive(chessData[x + 1][y], x + 1, y) == false &amp;&amp; chessData[x + 1][y] == anotherRole(qi)&gt; || judgeLive(chessData[x][y + 1], x, y + 1) == false &amp;&amp; chessData[x][y + 1] == anotherRole(qi)&gt; || judgeLive(chessData[x][y - 1], x, y - 1) == false &amp;&amp; chessData[x][y - 1] == anotherRole(qi))&gt; &#123;&gt; &gt; return 1;&gt; &#125;&gt; else&gt; return 0;&gt; &gt; &#125;&gt; &gt; /*初始化jie数组*/&gt; void jieInit()&gt; &#123;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; jie[i][j] = false;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; &gt; /*----------------------主函数------------------------*/&gt; int main()&gt; &#123;&gt; jieInit();&gt; int qi, x, y;&gt; for (; cin &gt;&gt; qi &gt;&gt; x &gt;&gt; y;)&gt; &#123;&gt; if (chessData[x - 1][y - 1] == 0 &amp;&amp; jie[x - 1][y - 1] == false)&gt; &#123;&gt; jieInit();&gt; chessData[x - 1][y - 1] = qi;&gt; if (judgeLive(qi, x - 1, y - 1) == true) //如果自己可以存活&gt; &#123;&gt; chessAnotherClear(x - 1, y - 1); //寻找并清除敌方无气子&gt; &#125;&gt; if (judgeLive(qi, x - 1, y - 1) == false) //如果自己不可存活&gt; &#123;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 0) //如果周围可以存活，则禁入&gt; &#123;&gt; chessData[x - 1][y - 1] = 0;&gt; &#125;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 1) //如果周围不可存活，则提子&gt; &#123;&gt; chessAnotherClear( x - 1, y - 1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; showChessBoard();&gt; &#125;&gt; &gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端部分基础知识]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[doctype html的作用 它是html5标准网页声明,告诉浏览器用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。而混杂模式指的是浏览器用自己的方式解析代码，页面会以一种兼容的方式来显示。混杂模式一般会模拟老站点的行为以防止老站点无法工作。 常见的meta标签的含义 指定所用的字符集 &lt;meta charset=&quot;utf-8&quot;&gt; 向搜索引擎说明网页的搜索关键词 &lt;meta name=&quot;keywords&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的主要内容 &lt;meta name=&quot;description&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的作者 &lt;meta name=&quot;author&quot; content=&quot;CleFke*^▽^*&quot;&gt; 浏览器的内核控制 &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; 常见的浏览器的内核 普通的IE浏览器使用的是Trident Firefox使用的是Gecko opera使用的是Presto，以及后面的Blink Safari以及Chrome使用的是WebKit 常见的标签以及含义 标签 含义 &lt;html&gt; HTML页面根元素 &lt;head&gt; 文档的头部 &lt;meta&gt; 为机器提供元数据，告诉机器如何解析 &lt;title&gt; 文档的标题 &lt;body&gt; 文档的内容 &lt;div&gt; 块级元素，容器 &lt;h1&gt; 定义一级标题，类似还有&lt;h2&gt;等 &lt;p&gt; 定义一个段落 &lt;a&gt; 定义一个链接，格式为&lt;a href=&quot;网址&quot;&gt; &lt;span&gt; 内联元素，可用作文本的容器 &lt;u&gt; 下划线标签 &lt;em&gt; 强调标签 &lt;strong&gt; 加重标签 &lt;table&gt; 表格标签 &lt;tr&gt; 表格中的行 &lt;td&gt; 表格中的单元格 &lt;th&gt; 表格的表头 &lt;tbody&gt; 表格的主体 &lt;tfoot&gt; 表格的页脚 &lt;ol&gt; 有序列表标签 &lt;ul&gt; 无序列表标签 &lt;li&gt; 定义列表项目 &lt;img&gt; 插入图片，格式为&lt;img src=&quot;图片地址&quot;&gt; &lt;br&gt; 换行标签 &lt;input&gt; 输入控件标签 &lt;i&gt; 斜体字标签 &lt;hr&gt; 水平线标签 &lt;iframe&gt; 定义内联框架 &lt;cite&gt; 定义作品标题 &lt;button&gt; 按钮标签 &lt;b&gt; 粗体字标签 &lt;form&gt; 定义供用户输入的表单 &lt;caption&gt; 定义表标题 &lt;footer&gt; 定义文档页脚]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些莫名其妙的东西]]></title>
    <url>%2F2019%2F08%2F31%2F%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[写在前面 在室友的怂恿下，莫名其妙的有了搭建blog的想法，就首先感谢下铺的大哥的支持。由于一些众所周知的原因（没钱）这个小站基于Hexo+GitHub搭建。平时主要用来发表一些文章，一点感悟。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
</search>
