<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安装sbt以及maven打包程序遇到的一些问题]]></title>
    <url>%2F2021%2F04%2F02%2F%E5%AE%89%E8%A3%85sbt%E4%BB%A5%E5%8F%8Amaven%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[sbt换国内源报错记录 在首次尝试运行时，有如下报错： 查阅资料发现需要手动配置代理，按照教程 12cd /usr/local/sbt/confvim sbtconfig.txt 添加如下代理 12-Dhttp.proxyHost=proxy-Dhttp.proxyPort=8080 添加后仍然报错，发现 /conf 目录下的两个文件 sbtconfig.txt 仅适用Windows，sbtopts适用Mac/Linux 于是更改后者文件 1vim ./conf/sbtopts 重新添加上述代理，并在末尾新增 1-Dsbt.override.build.reops=true 运行成功 12[info] Set current project to sbt (in build file:/usr/local/sbt/)[info] 1.3.8 mvn打包失败使用mvn命令打包，报错如下： 1sudo: /usr/local/maven/bin/mvn：找不到命令 没有找到解决方案，于是将maven删除，使用apt-get下载 1sudo apt-get install maven 下载后查看maven版本 1mvn -v 12345Apache Maven 3.6.0Maven home: /usr/share/mavenJava version: 1.8.0_162, vendor: Oracle Corporation, runtime: /usr/lib/jvm/jdk1.8.0_162/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;5.4.0-71-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; 若替换为国内源，在下述位置更改settings.xml文件,在&lt;mirrors&gt;里面添加如下镜像 123456789101112131415161718192021222324252627282930&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云谷歌仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/google&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云spring仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云spring插件仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt;&lt;/mirror&gt; 12cd /usr/share/maven/confsudo vim settings.xml #这里要用sudo，该文件是只读文件，不然无法编辑 添加镜像的时候有个坑，它的xml文件里面是有mirrors目录的，参照了这篇博客,最后解决 ps 使用apt-get install 指令是时，下载的文件有如下路径： 1234/usr/share #文件的位置，其中conf配置文件也有可能在/share的此软件目录下，例如上述 maven配置文件在/usr/share/maven/conf下/usr/bin #可执行文件位置/etc #配置文件位置/usr/lib #lib文件位置 重新进行打包 12cd ~/sparkapp2mvn package 成功 1234567[INFO] Building jar: /home/hadoop/sparkapp2/target/simple-project-1.0.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:10 min[INFO] Finished at: 2021-04-02T14:01:49+08:00[INFO] ------------------------------------------------------------------------]]></content>
      <categories>
        <category>大数据学习</category>
      </categories>
      <tags>
        <tag>spark maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装双系统以及ssr总结]]></title>
    <url>%2F2021%2F03%2F31%2F%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8Assr%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面在自己电脑上安装了Ubuntu双系统，并安装了一些基础软件，中间遇到了很多问题，遂作记录 电脑版本电脑是联想拯救者 256G固态硬盘 + 1T机械硬盘 即 UEFI 新式bios 双硬盘 查看自己是否是UEFI还是传统MBR win + r 输入 msinfo32 如下： 这个版本很重要，之前看错了教程走了弯路，双硬盘的安装双系统有一些区别。 参考的是这篇教程，写的很详细，感谢大哥 装系统记录首先是下载Ubuntu系统镜像文件，直接到官网下载，我下载的版本是Ubuntu 18.04 LTS 然后是制作启动盘，这里，如果是新版UEFI的可以直接把下载好的 iso文件解压到你的u盘。但为了不出错，仍然安装传统的方法制作启动盘。 首先下载启动盘制作工具 这里我使用的是 UltraISO 直接下载安装一套组合拳，然后点击试用即可，详细看文章开头大哥的教程 然后插入你的u盘，这里制作启动盘参考百度的教程，不赘述。 注意点： 这里的u盘需要8G以上，不然装不下，而且U盘内容在安装的过程中会被清空，需要提前备份 也可以使用移动硬盘，但在格式化的时候要注意格式化的格式 到这里，已经制作好了你的启动盘，可以在此电脑里面看到它，注意，不要去动它。 然后是进行系统分区右键此电脑-&gt;点击管理-&gt;点击磁盘管理-&gt;进行分区 如图所示，红色框中，我已经安装好了系统。但新开辟出来的空间应该是黑色或绿色的而不是蓝色。 注意： 因为是双硬盘，所以最好在你的固态硬盘单独开辟一块空间用来放Ubuntu的系统文件（200M），这样，在每次开机的时候自动检测，可以自主选择进入Ubuntu还是Windows系统 接下来进行bios设置重启电脑，在显示开机页面时进入bios，将Secure Boot 关闭。 注意:因为刚刚在固态硬盘开辟了空间，但实际上，安装Ubuntu时是看不见此固态盘的，还需要进行如下设置： 将BIOS中的SATA设置改为AHCI，然后保存更改并退出 此时，准备工作做完重启按F12（联想拯救者）进入启动页，选择u盘，一路按照文章开头教程即可。 SSR配置在Windows下有完整的客户端，在Ubuntu中，有两种方式，一是直接下载SSR脚本，处理配置文件，开始时我使用这种，但中间出了很多毛病。 最后，找到了一个名为electron-ssr的图形化界面的软件 https://github.com/shadowsocksrr/electron-ssr/releases/tag/v0.2.7 由于一些熟知的原因，很多时候上不去github，可将github.com替换为hub.fastgit.org 参考这位大哥的方法，下载安装 Ubuntu下deb为安装文件，就像windows下的安装文件一样，下载下来进行安装，比较简单。 接下来进入安装包的下载目录进行安装 1sudo dpkg -i electron-ssr-0.2.7.deb 安装完后，直接启动 1electron-ssr 这里遇到了一个问题electron-ssr是ssr的图形界面，所以在第一次启动时会自动下载 ssr python包，但由于网络问题，发现上不去，无法自动下载。 报错与这位兄弟类似： 一开始以为是之前下载的ssr服务开着，然后把他卸载了发现还是不行。重装软件，最后依然没找到解决方法。 索性手动下载 123sudo apt-get install git #没有git的话先把git下载了git clone https://github.com/shadowsocksr/shadowsocksr.git#如果下载太慢或这上不去就参照上面的将github.com替换为hub.fastgit.org 然后进入下载目录下的/shadowsocksr/bin 在里面应该能看到一个local.py文件，如果没有看到就在重新找找，找到后，将此路径添加到electron-ssr的python包处，即可。 然后配置你的代理信息，并且在Ubuntu的系统设置设置代理，这位大哥写了详细的操作步骤。 大功告成]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Ubuntu ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FIRST集和FOLLOW集的理解和补充]]></title>
    <url>%2F2020%2F11%2F26%2FFIRST%E9%9B%86%E5%92%8CFOLLOW%E9%9B%86%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[写在前面编译原理，关于FIRST集和FOLLOW集部分的笔记，本文参考了另一篇博客，在此基础上加入了一些个人的理解。 FIRST集定义设文法 $G= (V_T,V_N,S,P)$是上下文无关文法，则有 $$FIRST(\alpha) ={a|\alpha\Rightarrow^*a…,a\in V_T} $$ 例子 后面是终结符 12345&gt; A-&gt;aB|ε&gt; A-&gt;c&gt; &gt; FIRST(A) = &#123;a,c,ε&#125;&gt; 因为A能直接得到的第一个终结符包括a，c，ε，所以把他们加入。 后面是非终结符（一） 12345&gt; A-&gt;Ba&gt; B-&gt;b&gt; &gt; FIRST(A) = &#123;b&#125;&gt; A能直接得到的是一个非终结符，而这个非终结符只能得到一个终结符b，所以把b加入。 后面是非终结符（二） 12345&gt; A-&gt;Bc&gt; B-&gt;b|ε&gt; &gt; First(A)=&#123;b,c&#125;&gt; 注意，这里没有把ε也加入到First集中，是因为A通过B得到ε时，还能继续向后，也就是说将ε代换到第一个式子里面，后面还有一个非终结符c，所以不能把ε加入。 我们可以说$First(B)={b,ε}$，这是显然的。 后面是非终结符（三） 123456&gt; A-&gt;BC&gt; B-&gt;b|ε&gt; C-&gt;c|ε&gt; &gt; First(A)=&#123;b,c,ε&#125;&gt; 对比第3条，为什么这里又把ε加入了，是因为将ε代换B后，继续向后，发现C也能被ε代换，于是应用了课本第三条规则，即$A-&gt;ε$,此时可以将ε加入到First集。 FOLLOW集定义设S是文法G的开始符号，对于G中的任何一个非终结符A，则有 $$FOLLOW(A) ={a|S\Rightarrow^*…Aa…,a\in V_T} $$ 理解$FOLLOW(A)$就是紧跟在A后面的终结符集和或者结束符$’$‘$ 求解规则 对于文法的开始符号S,则把$$$放进Follow（S）中； 若$A-&gt;αBβ$是一个产生式，则把$First(β)$中除了ε以外的符号加入到Follow（B）中； 若$A-&gt;αB$是一个产生式，或$A-&gt;αBβ$是一个产生式且$First(\beta)$中包含ε，则把$Follow(A)$加入到$Follow(B)$中]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>FIRST集</tag>
        <tag>FOLLOW集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的轮子（一）]]></title>
    <url>%2F2020%2F07%2F22%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AE%E5%AD%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[队列 初始化 1Queue&lt;Integer&gt; q = new LinkedList(); 获取队首元素（如果队列为空则返回null） 1q.peek() 入队 1q.offer(data) //data 即入队元素 出队 1q.poll() //队列 先进先出 出队为对首元素 获取队列大小 1q.size() 栈 初始化 1Stack&lt;Integer&gt; s = new Stack&lt;&gt;() 入栈 1s.push(data) //data即是入栈元素 出栈 1s.pop() //先进后出 栈顶出栈 判断栈是否为空 1s.empty() //return boolean,'true' means empty 获取栈顶元素 1s.peek() //get the top element 获取栈大小（元素个数） 1s.size()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet url-pattern路径匹配问题]]></title>
    <url>%2F2020%2F05%2F16%2FServlet-url-pattern%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面 在Servlet映射过程中，遇到了一个路径匹配的问题，遂做记录。 如图所示 原思路在login.html页面中有一个form表单，现在想利用action属性提交信息。 于是在xml文件中配置了如下信息： 12345678&lt;servlet&gt; &lt;servlet-name&gt;LoginCheck&lt;/servlet-name&gt; &lt;servlet-class&gt;com.login.Users&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginCheck&lt;/servlet-name&gt; &lt;url-pattern&gt;/loginCheck&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在表单属性中： 1&lt;form action="loginCheck" method="post"&gt; 问题此时，是找不到loginCheck目标的。经过查阅网上资料，发现url-pattern属性的初识位置是/web页面，若直接写/loginCheck表示从web根目录下面找文件。 解决因为目标在login.html里，html文件夹下，所以需要修改url-pattern的值为： 1&lt;url-pattern&gt;/html/loginCheck&lt;/url-pattern&gt; 这样才表示去html文件夹下寻找目标，才能正确匹配上。]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP实现简单登录]]></title>
    <url>%2F2020%2F05%2F09%2FJSP%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写在前面 在接触了JSP后，跟着老师简单做了一个小demo，模拟的登录操作 过程描述 首先是一个登录页面，通过表单接收数据； 将得到的数据封装进request对象，封装的内容为表单填写内容； 通过表单的method属性，用post方法发送到action指定的jsp文件，即检查用户信息的文件； 在检查文件连接数据库，并取出request传来的数据，传入sql语句进行数据库的匹配； 进入判断逻辑。判断成功，则通过jsp的forward page方法跳转到登陆成功页面，并携带参数；或是判断失败，跳转至失败页面。 代码 login.jsp 12345678910111213141516171819202122232425262728293031323334&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Login&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div style="text-align: center"&gt;&gt; &lt;h1&gt;Login&lt;/h1&gt;&gt; &lt;hr&gt;&gt; &lt;form action="login_check.jsp" method="post"&gt;&gt; &lt;table border="1"&gt;&gt; &lt;tr&gt;&gt; &lt;td colspan="2"&gt;Users Login&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td&gt;Login ID: &lt;/td&gt;&gt; &lt;td&gt;&lt;input type="text" name="id"&gt;&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td&gt;Password: &lt;/td&gt;&gt; &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;tr&gt;&gt; &lt;td colspan="2"&gt;&gt; &lt;input type="submit" value="Submit"&gt;&gt; &lt;input type="reset" value="Reset"&gt;&gt; &lt;/td&gt;&gt; &lt;/tr&gt;&gt; &lt;/table&gt;&gt; &lt;/form&gt;&gt; &lt;/div&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; login_check.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&gt; &lt;%--&gt; Created by IntelliJ IDEA.&gt; User: li&gt; Date: 2020/5/9&gt; Time: 10:53&gt; To change this template use File | Settings | File Templates.&gt; --%&gt;&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;%@ page import="java.sql.*"%&gt;&gt; &lt;%@ page import="javax.xml.stream.events.StartDocument" %&gt;&gt; &lt;%@ page import="javax.print.attribute.standard.PresentationDirection" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Check&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &gt; &lt;%!&gt; public static final String DRIVER = "com.mysql.jdbc.Driver";&gt; public static final String URL = "jdbc:mysql://localhost:3306/logintest?characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8";&gt; public static final String USER = "####";&gt; public static final String PASSWORD = "####";&gt; %&gt;&gt; &lt;%&gt; Connection con = null; //数据库连接对象&gt; PreparedStatement pstmt = null; //数据库操作&gt; ResultSet res = null; //结果集&gt; boolean flag = false; //是否登录成功标志&gt; String name = null;&gt; %&gt;&gt; &lt;%&gt; try &#123;&gt; Class.forName(DRIVER); //加载驱动&gt; try &#123;&gt; con = DriverManager.getConnection(URL,USER,PASSWORD); //获取数据库连接&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; String sql = "SELECT name FROM admininfo WHERE id=? AND password=?";&gt; /*这个语句中的？表示占位符，相当于一个未知量，通过下面的setString方法，可以填充占位符的值*/&gt; &gt; pstmt = con.prepareStatement(sql); //实例化数据库操作对象&gt; &gt; /*这里的request是从login.jsp页面表单提交的数据，经过封装，传递过来，分别有两个参数 id和password*/&gt; /*通过request带有的方法可以分别获取到传递的数据*/&gt; try &#123;&gt; pstmt.setString(1,request.getParameter("id"));&gt; pstmt.setString(2,request.getParameter("password"));&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &gt; res = pstmt.executeQuery(); //此语句只能查询，若要执行insert delete update等操作 须使用execute方法&gt; &gt; if(res.next())&#123;&gt; name = res.getString(1); //参数1表示取第一列值&gt; flag = true;&gt; &#125;&gt; &#125; catch (ClassNotFoundException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &gt; //finally语句是在try的return语句执行之后，return返回之前执行&gt; finally &#123;&gt; try &#123;&gt; if(res != null)&#123;&gt; res.close();&gt; &#125;&gt; if(pstmt != null)&#123;&gt; pstmt.close();&gt; &#125;&gt; if(con != null)&#123;&gt; con.close();&gt; &#125;&gt; &#125; catch (SQLException e) &#123;&gt; System.out.println(e.toString());&gt; &#125;&gt; &#125;&gt; %&gt;&gt; &gt; &lt;%&gt; if(flag)&#123;&gt; %&gt;&gt; &lt;jsp:forward page="login_success.jsp"&gt;&gt; &lt;jsp:param name="username" value="&lt;%=name%&gt;"/&gt;&gt; &lt;/jsp:forward&gt;&gt; &lt;%&gt; &#125;else&#123;&gt; %&gt;&gt; &lt;jsp:forward page="login_failure.jsp"&gt;&lt;/jsp:forward&gt;&gt; &lt;%&gt; &#125;&gt; %&gt;&gt; &gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; login_success.jsp 1234567891011121314151617181920212223&gt; &lt;%--&gt; Created by IntelliJ IDEA.&gt; User: li&gt; Date: 2020/5/9&gt; Time: 10:53&gt; To change this template use File | Settings | File Templates.&gt; --%&gt;&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;Login success&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;Login success!&lt;/h1&gt;&gt; &lt;h2&gt;Welcome!&gt; &lt;span style="color: red"&gt;&gt; &lt;%=request.getParameter("username")%&gt;&gt; &lt;/span&gt;&gt; &lt;/h2&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; login_failure.jsp 123456789101112131415&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;meta charset="UTF-8"&gt;&gt; &lt;title&gt;Failure&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;Login failure&lt;/h1&gt;&gt; &lt;h2&gt;&gt; Please try again!&gt; &lt;a href="login.jsp" style="color: red"&gt;Click here!&lt;/a&gt;&gt; &lt;/h2&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; 遇到的问题 在数据库连接关闭的时候需要加入判断逻辑，判断为非空才能正常关闭； 需要项目导入mysql-connector-java-8.0.20.jar包，首先要配置到项目下，然后再添加到Tomcat的lib库中。并且要注意版本的匹配问题，否则会导致连接失败。 项目中我的各个版本为 12345&gt; Mysql: 8.0.18&gt; Tomcat: 9.0.34&gt; connetion-jar包: 8.0.20&gt; jdk: 11.0.6&gt; 附上最后成功的截图 为什么要用Tomcat？一般的，可以用html语言直接编写前端界面，并且通过js渲染，css美化。但这个过程是一个静态的，只是相当于把数据发送给浏览器进行解析，相当于面对客户端的。 而Tomcat是生成一个动态的页面，在html中嵌入jsp语言，生成的页面是通过服务器端发送出来。而Tomcat相当于一个中间的工具，帮助我们实现了这个过程，把我们自己的电脑变成了服务器端。 关于具体机制，下次学到再说 ☆(￣▽￣)/$:*]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>JSP HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发基础]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 微信小程序开发跟前端网页开发流程类似，它是基于微信的架构下，所以须使用专门的环境。即便如此，还是有很多的问题。 前置准备 首先需要到官网注册一个小程序账号，之后一路填写相关信息。注意！在选择小程序类别的时候，第一类别如果选的游戏，那么只能进行小游戏开发；选择其他类别，才可以进行普通小程序开发。 注册完成后，可看到如下页面 在-开发-开发设置目录下，可以看到自己已经创建好的小程序ID，小程序秘钥 接下来根据系统类型在官网下载开发环境 配置好后进入，会要求填写之前生成的小程序ID，填写完毕后即可进入开发界面 文件结构 在环境内，可以看到类似如下的文件结构 其中 /images 目录为自定义的文件夹，用于存放图片 /pages 目录用于存放页面文件 /utils 目录用于存放工具文件 /app.js 存放页面初识的状态，一般为登录状态 /app.json 存放所有的页面路径 /app.wxss 存放总页面样式文件，类比css文件 开发准备 在开发环境内可以看到一个默认生成的页面，功能是点击获取头像。在第一次开发时，可以将 /util文件全部删除，将/pages目录下的logs文件全部删除，将index.wxml，index.wxss，index.js中全部代码删除 在index.js中输入page 通过tab补全page页面函数 此时的一个页面文件结构如下所示 此时一个index文件夹表示一个页面的全部逻辑，同理，可以创建多个文件，生成多个文件夹 wxml文件以及wxss文件分别对应html和css文件 每创建一个新的页面，需要在app.json中声明路径，否则会有报错 如图所示，第一个页面路径表示初始页面，也就是主页面；后面的路径表示其他自定义的页面 若想要实现各个页面之间的跳转逻辑，可在主页面的js文件中自定义跳转函数（官方类库 wx.navigateto），当遇到跳转事件时就可以以完成跳转 如图所示，此函数表示遇到事件执行时跳转到url对应路径下 遇到的问题 第一次接触时，结合网上代码想要实现一个贪吃蛇小程序，结果在调试端正常执行，在手机端无法正常运行。原因是微信原则上不允许开发者在小程序上开发游戏，所以进行了限制，如贪吃蛇中用到的页面刷新逻辑在手机端被加以了限制。 微信小程序在打包上传时有大小限制，2M，所以如果文件中有图片或者其他大文件，需压缩处理，或者将图片放到网上图床。 第一次上传时可以直接选体验版上传，不审核。 最后 贴一个当时想用requestAnimationFrame方法结果发现被限制了，只能在小游戏开发中用，然后找到了一个别人做好的轮子 1234567891011121314&gt; var lastFrameTime = 0;&gt; // 模拟 requestAnimationFrame&gt; var doAnimationFrame = function (callback) &#123;&gt; var currTime = new Date().getTime();&gt; var timeToCall = Math.max(0, 16 - (currTime - lastFrameTime));&gt; var id = setTimeout(function () &#123; callback(currTime + timeToCall); &#125;, timeToCall);&gt; lastFrameTime = currTime + timeToCall;&gt; return id;&gt; &#125;;&gt; // 模拟 cancelAnimationFrame&gt; var abortAnimationFrame = function (id) &#123;&gt; clearTimeout(id)&gt; &#125;&gt; 以及，我的图标在哪找的这里！]]></content>
      <categories>
        <category>微信小程序学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编中变址寻址操作易错点]]></title>
    <url>%2F2020%2F05%2F07%2F%E6%B1%87%E7%BC%96%E4%B8%AD%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%93%8D%E4%BD%9C%E6%98%93%E9%94%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面 在汇编语言中，针对数组操作，可以使用间接寻址，或者变址寻址。在变址寻址操作时，遇到了一系列问题，遂做总结，避免再犯。 问题描述 有一个带有8个WORD型数据的数组，想要对其偶数项进行求和 间接寻址方法12345678910111213141516171819202122232425262728; Operators (Operator.asm); Demonstrates the TYPE, LENGTHOF, and SIZEOF operators.386.model flat,stdcall.stack 4096ExitProcess PROTO,stdcall:dword.dataarrofw WORD 1,2,1,2,1,2,1,2 ;数据中，偶数序求和结果为2*4，奇数序求和为1*4sum WORD 0.codemain PROC mov EDI,OFFSET arrofw add EDI,2 ;现在指向第二个数据 mov ECX,LENGTHOF arrofw mov AX,0L1: add AX,[EDI] ;依次累加 add EDI,2*TYPE arrofw ;求偶数序，所以向后偏移 LOOP L1 mov sum,AX invoke ExitProcess,0main ENDPEND main 带比例因子的变址寻址方法123456789101112131415161718192021222324252627; Operators (Operator.asm); Demonstrates the TYPE, LENGTHOF, and SIZEOF operators.386.model flat,stdcall.stack 4096ExitProcess PROTO,stdcall:dword.dataarrofw WORD 1,2,1,2,1,2,1,2 ;数据中，偶数序求和结果为2*4，奇数序求和为1*4sum WORD 0.codemain PROC mov AX,0 mov ESI,1 mov ECX,LENGTHOF arrofwL1: add AX,arrofw[ESI*TYPE arrofw] ;依次累加 add ESI,2 ;求偶数序，所以每次加2 LOOP L1 mov sum,AX invoke ExitProcess,0main ENDPEND main 犯的错误 在使用寄存器时，没有考虑数据类型为WORD型，应该使用16位寄存器AX，而不是32位的EAX等等寄存器； 为什么又使用了EDI，ESI等寄存器？因为在OFFSET指令中，返回的地址一般为32位的，所以用32位的EDI寄存器来存；ESI同理。 这里不能用DI或者SI]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>间接寻址</tag>
        <tag>带比例因子的变址寻址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[围棋算法]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%9B%B4%E6%A3%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面 围棋是世界范围内非常流行的棋类运动，是竞技体育项目。围棋的规则非常简单，做为编程初学者逻辑思维训练非常合适。 标准围棋棋盘是19行19列。为了简化起见，此处简化成9行9列。标准围棋对弈方法是黑方和白方轮番下棋，为了简化，本算法引擎，支持任意的落子顺序，即落子顺序由程序输入输入(棋子角色，棋子行号，棋子列号)​ 1 2 3 表示白子放第2行第3列 2 3 3 表示黑子放第3行第3列 本算法引擎实现的是。从落子序列到棋盘状态的映射，当落子完成后，输出最终的棋盘状态。 +代表空白，o代表白棋，#代表黑棋 例如1 1 11 1 21 2 11 2 2输出四颗白子形成的正方形状围棋对战算法引擎需要实现各种围棋规则(提子，禁入点，反扑，劫)。具体的规则示意图请自行网上查阅。 样例 输入： 1 1 1 2 2 2 输出： ​ 1 2 3 4 5 6 7 8 9 1 o + + + + + + + + 2 + # + + + + + + + 3 + + + + + + + + + 4 + + + + + + + + + 5 + + + + + + + + + 6 + + + + + + + + + 7 + + + + + + + + + 8 + + + + + + + + + 9 + + + + + + + + + 逻辑思路 输入数据后，判断该位置是否为空，空位可落子 每次输入数据时调用jieInit（）函数初始化，（用一个数组单独记录棋盘上一轮被提走的棋子的位置） 调用judgeLive（）函数判断自己落子的位置是否会处于自杀状态 （1）如果是，则调用chessAnotherJudge（）函数判断周围是否有敌方棋子即将被杀（反扑） ​ a.如果是，则执行反扑chessAnotherClear（）（寻找并清除周围敌方濒死棋子） ​ b.如果否，则该点为禁入点，不可落子 ​（2）如果否，则直接判断周围是否有敌方棋子即将被杀，并视情况执行清除敌方命令 打劫，每次有棋子被提走后，jie[][]会记录提走的位置，并将记录保存到下一次输入后，在下一次输入判断时，会直接判断是否为劫 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&gt; #include&lt;iostream&gt;&gt; using namespace std;&gt; /*---------------------全局变量------------------*/&gt; &gt; int chessData[9][9]; //定义每个位置状态，0为空，1为白，2为黑&gt; const char chessChar[3]&#123; '+','o','#' &#125;;&gt; bool jie[9][9];&gt; &gt; /*---------------------函数-------------------*/&gt; &gt; /*打印棋盘*/&gt; void showChessBoard(void)&gt; &#123;&gt; cout &lt;&lt; " ";&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1;&gt; &#125;&gt; cout &lt;&lt; endl;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; cout &lt;&lt; " " &lt;&lt; i + 1 &lt;&lt; " ";&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; int data = chessData[i][j];&gt; cout &lt;&lt; chessChar[data] &lt;&lt; " ";&gt; &#125;&gt; cout &lt;&lt; endl;&gt; &#125;&gt; &#125;&gt; &gt; /*寻找相反状态*/&gt; int anotherRole(int qi)&gt; &#123;&gt; if (qi == 1)&gt; return 2;&gt; if (qi == 2)&gt; return 1;&gt; &#125;&gt; &gt; /*具体执行递归判定*/&gt; bool judgeNeigbourLive(int role, int x, int y, bool footprint[])&gt; &#123;&gt; if (x &lt; 0 || x &gt;= 9 || y &lt; 0 || y &gt;= 9)//如果我超界，返回false&gt; &#123;&gt; return false;&gt; &#125;&gt; if (footprint[x * 9 + y] == true) //如果我来过这个地方，返回false，不在判断&gt; &#123;&gt; return false;&gt; &#125;&gt; if (chessData[x][y] == 0) //如果我为空，则邻居必定存活，即有气&gt; &#123;&gt; return true;&gt; &#125;&gt; if (chessData[x][y] == anotherRole(role))//如果我跟邻居的状态不同，则不判断&gt; &#123;&gt; return false;&gt; &#125;&gt; &gt; footprint[x * 9 + y] = true;//每次判断完一个位置后就把该位置设为true，表示来过&gt; &gt; //如果我跟邻居的状态相同，则递归判断邻居&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125;&gt; &gt; /*递归判定是否存活*/&gt; bool judgeLive(int role, int x, int y)&gt; &#123;&gt; bool footprint[9 * 9] = &#123; false &#125;; //用足迹记录下每一次走过的位置，避免重复判定引起无穷递归&gt; return judgeNeigbourLive(role, x - 1, y, footprint)&gt; || judgeNeigbourLive(role, x + 1, y, footprint)&gt; || judgeNeigbourLive(role, x, y - 1, footprint)&gt; || judgeNeigbourLive(role, x, y + 1, footprint);&gt; &#125; &gt; &gt; /*清除传入点周围的敌方棋子*/&gt; void chessClear(int qi, int x, int y) //递归寻找所有相同状态的点并将其提起&gt; &#123;&gt; if (chessData[x - 1][y] == qi)&gt; &#123;&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; chessClear(qi, x - 1, y);&gt; &#125;&gt; if (chessData[x + 1][y] == qi)&gt; &#123;&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; chessClear(qi, x + 1, y);&gt; &#125;&gt; if (chessData[x][y - 1] == qi)&gt; &#123;&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; chessClear(qi, x, y - 1);&gt; &#125;&gt; if (chessData[x][y + 1] == qi)&gt; &#123;&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; chessClear(qi, x, y + 1);&gt; &#125;&gt; &#125;&gt; &gt; /*寻找传入点周围的濒死敌方棋子并提供信息给chessClear函数*/&gt; void chessAnotherClear(int x, int y) //判断落子后邻居是否存活，若死亡，则连片提子&gt; &#123;&gt; if (judgeLive(chessData[x - 1][y], x - 1, y) == false) //如果点左边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x - 1][y], x - 1, y);&gt; chessData[x - 1][y] = 0;&gt; jie[x - 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x + 1][y], x + 1, y) == false) //如果点右边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x + 1][y], x + 1, y);&gt; chessData[x + 1][y] = 0;&gt; jie[x + 1][y] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y + 1], x, y + 1) == false) //如果点上边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y + 1], x, y + 1);&gt; chessData[x][y + 1] = 0;&gt; jie[x][y + 1] = true;&gt; &#125;&gt; if (judgeLive(chessData[x][y - 1], x, y - 1) == false) //如果点下边不可存活，调用函数删除与该点连成片的所有点（上下左右）&gt; &#123;&gt; chessClear(chessData[x][y - 1], x, y - 1);&gt; chessData[x][y - 1] = 0;&gt; jie[x][y - 1] = true;&gt; &#125;&gt; &#125;&gt; &gt; /*判定传入点周围是否存在濒死敌方棋子*/&gt; bool chessAnotherJudge(int qi,int x, int y) &gt; &#123;&gt; if ((judgeLive(chessData[x - 1][y], x - 1, y) == false &amp;&amp; chessData[x - 1][y]==anotherRole(qi)) //如果四周存在必死的棋子，且必死的棋子为敌方棋子，则返回1，表示这个位置可以落子&gt; || judgeLive(chessData[x + 1][y], x + 1, y) == false &amp;&amp; chessData[x + 1][y] == anotherRole(qi)&gt; || judgeLive(chessData[x][y + 1], x, y + 1) == false &amp;&amp; chessData[x][y + 1] == anotherRole(qi)&gt; || judgeLive(chessData[x][y - 1], x, y - 1) == false &amp;&amp; chessData[x][y - 1] == anotherRole(qi))&gt; &#123;&gt; &gt; return 1;&gt; &#125;&gt; else&gt; return 0;&gt; &gt; &#125;&gt; &gt; /*初始化jie数组*/&gt; void jieInit()&gt; &#123;&gt; for (int i = 0; i &lt; 9; i++)&gt; &#123;&gt; for (int j = 0; j &lt; 9; j++)&gt; &#123;&gt; jie[i][j] = false;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; &gt; /*----------------------主函数------------------------*/&gt; int main()&gt; &#123;&gt; jieInit();&gt; int qi, x, y;&gt; for (; cin &gt;&gt; qi &gt;&gt; x &gt;&gt; y;)&gt; &#123;&gt; if (chessData[x - 1][y - 1] == 0 &amp;&amp; jie[x - 1][y - 1] == false)&gt; &#123;&gt; jieInit();&gt; chessData[x - 1][y - 1] = qi;&gt; if (judgeLive(qi, x - 1, y - 1) == true) //如果自己可以存活&gt; &#123;&gt; chessAnotherClear(x - 1, y - 1); //寻找并清除敌方无气子&gt; &#125;&gt; if (judgeLive(qi, x - 1, y - 1) == false) //如果自己不可存活&gt; &#123;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 0) //如果周围可以存活，则禁入&gt; &#123;&gt; chessData[x - 1][y - 1] = 0;&gt; &#125;&gt; if (chessAnotherJudge(qi,x - 1, y - 1) == 1) //如果周围不可存活，则提子&gt; &#123;&gt; chessAnotherClear( x - 1, y - 1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; showChessBoard();&gt; &#125;&gt; &gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端部分基础知识]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[doctype html的作用 它是html5标准网页声明,告诉浏览器用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。而混杂模式指的是浏览器用自己的方式解析代码，页面会以一种兼容的方式来显示。混杂模式一般会模拟老站点的行为以防止老站点无法工作。 常见的meta标签的含义 指定所用的字符集 &lt;meta charset=&quot;utf-8&quot;&gt; 向搜索引擎说明网页的搜索关键词 &lt;meta name=&quot;keywords&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的主要内容 &lt;meta name=&quot;description&quot; content=&quot;啦啦啦&quot;&gt; 向搜索引擎说明站点的作者 &lt;meta name=&quot;author&quot; content=&quot;CleFke*^▽^*&quot;&gt; 浏览器的内核控制 &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; 常见的浏览器的内核 普通的IE浏览器使用的是Trident Firefox使用的是Gecko opera使用的是Presto，以及后面的Blink Safari以及Chrome使用的是WebKit 常见的标签以及含义 标签 含义 &lt;html&gt; HTML页面根元素 &lt;head&gt; 文档的头部 &lt;meta&gt; 为机器提供元数据，告诉机器如何解析 &lt;title&gt; 文档的标题 &lt;body&gt; 文档的内容 &lt;div&gt; 块级元素，容器 &lt;h1&gt; 定义一级标题，类似还有&lt;h2&gt;等 &lt;p&gt; 定义一个段落 &lt;a&gt; 定义一个链接，格式为&lt;a href=&quot;网址&quot;&gt; &lt;span&gt; 内联元素，可用作文本的容器 &lt;u&gt; 下划线标签 &lt;em&gt; 强调标签 &lt;strong&gt; 加重标签 &lt;table&gt; 表格标签 &lt;tr&gt; 表格中的行 &lt;td&gt; 表格中的单元格 &lt;th&gt; 表格的表头 &lt;tbody&gt; 表格的主体 &lt;tfoot&gt; 表格的页脚 &lt;ol&gt; 有序列表标签 &lt;ul&gt; 无序列表标签 &lt;li&gt; 定义列表项目 &lt;img&gt; 插入图片，格式为&lt;img src=&quot;图片地址&quot;&gt; &lt;br&gt; 换行标签 &lt;input&gt; 输入控件标签 &lt;i&gt; 斜体字标签 &lt;hr&gt; 水平线标签 &lt;iframe&gt; 定义内联框架 &lt;cite&gt; 定义作品标题 &lt;button&gt; 按钮标签 &lt;b&gt; 粗体字标签 &lt;form&gt; 定义供用户输入的表单 &lt;caption&gt; 定义表标题 &lt;footer&gt; 定义文档页脚]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些莫名其妙的东西]]></title>
    <url>%2F2019%2F08%2F31%2F%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[写在前面 在室友的怂恿下，莫名其妙的有了搭建blog的想法，就首先感谢下铺的大哥的支持。由于一些众所周知的原因（没钱）这个小站基于Hexo+GitHub搭建。平时主要用来发表一些文章，一点感悟。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
</search>
